#!/bin/bash
# Shell script to override the default archive for a new command shell

if test -f ~/.gitview 
then
  . ~/.gitview   # Environment
fi


SCM=${SCM:-$HOME/bin/git}
STDSOURCETREEROOT=$HOME/workspace
SOURCETREEROOT=${SOURCETREEROOT:-$STDSOURCETREEROOT}
EDITOR=${EDITOR:-/bin/vi}
SHELLCMD=/bin/bash   # Assumed to be a bash compatible shell
FINDCMD=/usr/bin/find   # Assumed to be a POSIX compatible find
VIEWMAXDEPTH=7
export VIEWMAXDEPTH SCM SOURCETREEROOT SHELLCMD FINDCMD

function findarchives()
{
   opts="$1"
   $FINDCMD $SOURCETREEROOT -maxdepth $VIEWMAXDEPTH -mindepth 1  -follow -type d -name .git $opts -not -path */.git/* -exec dirname {} \;
}
export -f findarchives

function fusage()
{
   echo "$msg"
   /bin/cat <<EOT
   setview: override the default archive, setup a direct Arch command environment
   For general help inside of a view, type "viewhelp"

   Synopsis: 
      setview { viewname | -v viewname | --view viewname | --viewname viewname } [options]
      setview [-h | --help] 

   Options:
      --editlog       ...edit the next commit log and continue
      --task message  ...branch locally, add and commit with the given message automatically upon normal shell exit
      --exec cmdlist  ...execute the commands under the view and exit
      --pause msg     ...prompt with a message and pause just before exiting

   Examples:
      setview myview
      setview -v myview

      setview --view myview --exec "git add flarg.cpp"
      setview --view myview --editlog

   When run without arguments, setview prompts interactively for a view name.
   It also prompts if a view name does not uniquely identify a view.

   Environment:
      EDITOR        ...the  --editlog option invokes the command in this variable 
                    to edit the log, or /bin/vi if not set

      VIEWMAXDEPTH  ...depth to search view root dir for {arch} source trees
                    Source trees are typically nested within customer-specific
		    or project-specific view subdirectories. This variable
		    lets you shorten the searches.

   Limitations:
   The --exec option may pose a risk based on your handling of SSH. 
   It is intended for invoking archive commends over a lan or intranet through 
   secured ssh connections. 
   
   This script is meant as a thin layer over the scm, not recommended for use in 
   public facing interfaces. 
EOT
}

names="";
editlog=0;
execcmd=0;
cmdstring="";
pause=0;
pausestring=0;
task=0;
while [[ ! -z "$1" ]]
do
   case $1 in
   -h|--help)
      fusage ;
      exit 0;
   ;;
   --debug) 
      export dbg="echo"
   ;;
   -v|--viewname|--view)
      if [[ -z "$2" ]]
      then
         echo "$1 missing an argument. Usage: " >&2;
         fusage;
         exit 1;
      else
         export view="$2";
         # mca 12/12/2005 pick up source trees at deep depths
         names=$(findarchives "-path $view")
         shift;
      fi
   ;;
   --editlog)
      editlog=1;
   ;;
   --pause)
      if [[ -z "$2" ]]
      then
         echo "$1 missing an argument. Usage: " >&2;
         fusage;
         exit 1;
      else
         pause=1
         pausestring="$2";
         shift;
      fi
   ;;
   --exec)
      if [[ -z "$2" ]]
      then
         echo "$1 missing an argument. Usage: " >&2;
         fusage;
         exit 1;
      else
         execcmd=1
         cmdstring="$2";
         shift;
      fi
   ;;
   --task)
      if [[ -z "$2" ]]
      then
         echo "$1 missing an argument. Usage: " >&2;
         fusage;
         exit 1;
      else
         task=1;
         taskmessage="$2";
         shift;
      fi
   ;;
   --*) # reject unknown args
         echo "$1 missing an argument. Usage: " >&2;
         fusage;
         read yorn
         exit 1;
   ;;
   *) # default to view name
      view=${1:-.*}
      # mca 12/12/2005 alter find logic to pick up source trees at much deeper depths
      names=$(findarchives|grep "$view")
   ;;
   esac
   shift; # get rid of $1
done


if [[ -z "$names" ]]
then
   # mca 12/12/2005 alter find logic to pick up source trees at much deeper depths
   echo "No view name specified, on view not found. Looking up views..." >&2;
   names=$(findarchives)
fi

num=$(echo $names | wc -w)
if [[ $num -eq 1 ]]
then
   view="$names"
fi

if [[ $num -eq 0 ]]
then
   echo "The view '$view' is not a view for any current archive."
   echo "Please select from the following:"
   # mca 12/12/2005 alter find logic to pick up source trees at much deeper depths
   select name in  $(find $SOURCETREEROOT -maxdepth $VIEWMAXDEPTH -mindepth 1  -follow -type d -name {arch} -not -path */{arch}/* -exec dirname {} \; echo "Quit";)
   do 
      if [[ ! -z "$name" ]]
      then
         view="$name";
         break;
      else
         echo "The selection you made is not an option. Quitting..."
	 exit
      fi
   done
else
  if [[ $num -gt 1 ]]
  then
   echo "Views by the name '$view' exist for multiple archives."
   echo "Please select from the following:"
   select name in  $names "Quit"
   do 
      if [[ ! -z "$name" ]]
      then
         view="$name";
         break;
      else
         echo "The selection you made is not an option. Quitting..."
	 exit 1
      fi
   done
  fi
fi

if [[ "$view" = "Quit" ]]
then
   exit;
fi

prompt=$(basename $view)
archname=$(basename $(dirname $view) )
   # locate archive source tree directory
   # this was necessary under arch/tla/bazaar, but not git
   # non-arch dvcs tools like git, in effect, use a remote repository as the "archive", or none at all

(
   thisarchive="$archname"
   thisview="$prompt"
   thishome="$view"
   VIEWHOME="$view"
   export PS1="$prompt: " 
   export thisview thisarchive thishome VIEWHOME

   cd "$VIEWHOME"
    
   # Shell function to list local views of existing archive projects
   function listviews() 
   {
     if [[ "$1" = "-l" ]]
     then
        find $SOURCETREEROOT -maxdepth $VIEWMAXDEPTH -mindepth 1  -follow -type d -name .git -not -path */.git/* -printf "%h\n"
     elif [[ "$1" = "-m" ]]
     then
        cd $SOURCETREEROOT
        find . -maxdepth $VIEWMAXDEPTH -mindepth 1  -follow -type d -name .git -not -path */.git/* -printf "%h\n" | while read name
        do
           fpart=$(basename $name)
           dirpart=${name##\./}
           dirpart=${dirpart%%/*}
           echo "$dirpart	~/$fpart"
        done
     else
        find $SOURCETREEROOT -maxdepth $VIEWMAXDEPTH -mindepth 1  -follow -type d -name .git -not -path */.git/* -printf "%h\n" | while read name 
        do
           basename $name 
        done
     fi
   }
   export -f listviews


   # Shell function to list archives
   function listarchives() 
   {
      ( cd $ARCHLOC ; ls )
   }
   export -f listarchives

   function lcd()
   {
      dir=${1:-$VIEWHOME}
      cd $dir
   }
   export -f lcd



   if [[ $task == "1" ]]    # Append task message to commit log
   then
      branchname="${taskmessage:0:12}_$(date +%H%M_%m%d%y)"
      branchname=${branchname// /_}
      $SCM branch ${branchname}
      trap "$SCM add .; $SCM commit -m \"branchname\"" EXIT
   fi

   if [[ "$editlog" == "1" ]]   # invoke editor on commit log
   then
      "$EDITOR" -- $($SCM make-log 2>/dev/null)
   fi

   if [[ $execcmd == "0" ]]
   then
         # Make the terminal window look 'reset'
      clear
      pwd
         # Invoke a new login under the reconfigured environment
      $SHELLCMD --login
   else
         # Using the reconfigured environment, execute the commands and then exit
      $SHELLCMD --login -c "$cmdstring"
   fi
)
if [[ $pause == "1" ]]
then
   read -p "$pausestring" yorn
fi
